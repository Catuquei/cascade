package cascade.features.modules.exploit;

import cascade.Cascade;
import cascade.event.events.MoveEvent;
import cascade.event.events.PacketEvent;
import cascade.event.events.PushEvent;
import cascade.event.events.UpdateWalkingPlayerEvent;
import cascade.features.modules.Module;
import cascade.features.setting.Setting;
import cascade.util.entity.EntityUtil;
import cascade.util.misc.MathUtil;
import cascade.util.misc.Timer;
import cascade.util.player.MovementUtil;
import cascade.util.player.PhysicsUtil;
import com.mojang.realmsclient.gui.ChatFormatting;
import io.netty.util.internal.ConcurrentSet;
import net.minecraft.block.material.Material;
import net.minecraft.client.gui.GuiDownloadTerrain;
import net.minecraft.entity.Entity;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketEntityVelocity;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class Clip extends Module {

    public Clip() {
        super("Clip", Category.EXPLOIT, "");
    }

    Setting<Float> factor = register(new Setting("Factor", 1.2f, 0.1f, 10.0f));
    Setting<Boolean> autoWalk = register(new Setting("AutoWalk", true));
    Setting<Boolean> onEdge = register(new Setting("OnEdge", false));
    Setting<Boolean> clip = register(new Setting("Clip", false));
    Setting<Boolean> teleport = register(new Setting("Teleport", false));
    Setting<Float> blocks = register(new Setting("Blocks", 0.3f, 0.0f, 20.0f, v -> teleport.getValue()));
    Setting<Boolean> tickShift = register(new Setting("TickShift", false));
    Setting<Integer> ticks = register(new Setting("Ticks", 2, 1, 100, v -> tickShift.getValue()));
    Setting<Timer> timer = register(new Setting("Timer", Timer.Strict));
    enum Timer {Strict, Fast, None}
    Setting<Rubberband> rubberband = register(new Setting("Rubberband", Rubberband.None));
    enum Rubberband {None, Desync, Cancel, Accept}
    int runs = 0;

    @Override
    public void onToggle() {
        if (timer.getValue() != Timer.None) {
            Cascade.timerManager.reset();
        }
        runs = 0;
    }

    @Override
    public void onUpdate() {
        if (fullNullCheck()) {
            return;
        }
        if (!edge() && onEdge.getValue()) {
            return;
        }
        if (!EntityUtil.isMoving() && !autoWalk.getValue()) {
            return;
        }
        if (timer.getValue() != Timer.None) {
            Cascade.timerManager.set(timer.getValue() == Timer.Fast ? 1.15f : 1.0888f);
        }
        if (tickShift.getValue()) {
            if (runs < ticks.getValue()) {
                runs++;
                PhysicsUtil.runPhysicsTick();
            } else {
                runs = 0;
            }
        }
        double cos = Math.cos(Math.toRadians(mc.player.rotationYaw + 90.0f));
        double sin = Math.sin(Math.toRadians(mc.player.rotationYaw + 90.0f));
        mc.player.setVelocity(0, 0, 0);
        MovementUtil.setMotion(0, 0, 0);
        if (clip.getValue()) {
            mc.player.noClip = true;
            mc.player.onGround = true;
            mc.player.collidedHorizontally = false;
            mc.player.capabilities.isFlying = false;
            mc.player.collidedVertically = false;
        }
        if (teleport.getValue()) {
            for (double x = 0.0625; x < blocks.getValue(); x += 0.262) {
                double[] dir = MathUtil.directionSpeed(x);
                mc.player.setLocationAndAngles(mc.player.posX + dir[0], mc.player.posY, mc.player.posZ + dir[1], mc.player.rotationYaw, mc.player.rotationPitch);
                mc.getConnection().sendPacket(new CPacketPlayer.Position(mc.player.posX + dir[0], mc.player.posY, mc.player.posZ + dir[1], mc.player.onGround));
            }
        }
        mc.player.setEntityBoundingBox(mc.player.getEntityBoundingBox().offset(factor.getValue() / 10.0 * cos, 0.0, factor.getValue() / 10.0 * sin));
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.Receive e) {
        if (isDisabled()) {
            return;
        }
        if (e.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook p = e.getPacket();
            switch (rubberband.getValue()) {
                case Desync: {
                    mc.getConnection().sendPacket(new CPacketPlayer.PositionRotation(mc.player.posX, mc.player.posY, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch, mc.player.onGround));
                    mc.player.setLocationAndAngles(mc.player.posX, mc.player.posY, mc.player.posZ, mc.player.rotationYaw, mc.player.rotationPitch);
                    break;
                }
                case Cancel: {
                    e.setCanceled(true);
                    break;
                }
                case Accept: {
                    mc.getConnection().sendPacket(new CPacketPlayer.PositionRotation(p.getX(), p.getY(), p.getZ(), mc.player.rotationYaw, mc.player.rotationPitch, mc.player.onGround));
                    mc.player.setLocationAndAngles(p.getX(), p.getY(), p.getZ(), mc.player.rotationYaw, mc.player.rotationPitch);
                    break;
                }
            }
        }
    }

    @Override
    public void onLogout() {
        if (isEnabled()) {
            disable();
        }
    }

    public boolean edge() {
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(-0.0625, 0.0, -0.0625)).isEmpty();
    }
}