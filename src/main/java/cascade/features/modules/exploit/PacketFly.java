package cascade.features.modules.exploit;

import cascade.Cascade;
import cascade.event.events.MoveEvent;
import cascade.event.events.PacketEvent;
import cascade.features.modules.Module;
import cascade.features.setting.Setting;
import cascade.mixin.mixins.accessor.ISPacketPlayerPosLook;
import cascade.util.misc.MathUtil;
import cascade.util.misc.TimeVec3d;
import cascade.util.misc.Timer;
import cascade.util.player.MovementUtil;
import cascade.util.player.PhysicsUtil;
import com.mojang.realmsclient.gui.ChatFormatting;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent;

import java.util.ArrayList;
import java.util.Map;
import java.util.Random;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

public class PacketFly extends Module {

    public PacketFly() {
        super("PacketFly", Category.EXPLOIT, "");
    }

    Setting<Page> page = register(new Setting("Page", Page.Phase));
    enum Page {Phase, TickBoost}
    Setting<Type> type = register(new Setting("Type", Type.Factor, v -> page.getValue() == Page.Phase));
    enum Type {Factor, SetBack, Fast, Slow, DeSync}
    Setting<Mode> packetMode = register(new Setting("Mode", Mode.LimitJitter, v -> page.getValue() == Page.Phase));
    enum Mode {Up, Preserve, Down, LimitJitter, Bypass, Obscure}
    Setting<Boolean> strict = register(new Setting("Strict", false, v -> page.getValue() == Page.Phase));
    Setting<Boolean> bounds = register(new Setting("Bounds", true, v -> page.getValue() == Page.Phase));
    Setting<Phase> phase = register(new Setting("Phase", Phase.NCP, v -> page.getValue() == Page.Phase));
    enum Phase {None, Vanilla, NCP}
    Setting<Boolean> multiAxis = register(new Setting("MultiAxis", false, v -> page.getValue() == Page.Phase));
    Setting<Boolean> noPhaseSlow = register(new Setting("NoPhaseSlow", false, v -> page.getValue() == Page.Phase));
    Setting<Float> speed = register(new Setting("Speed", 2.0f, 0.1f, 3.0f, v -> page.getValue() == Page.Phase));
    Setting<Float> factor = register(new Setting("Factor", 1.5f, 1.0f, 10.0f, v -> page.getValue() == Page.Phase && type.getValue() == Type.Factor || type.getValue() == Type.DeSync));
    Setting<AntiKick> antiKickMode = register(new Setting("AntiKick", AntiKick.Limited, v -> page.getValue() == Page.Phase));
    enum AntiKick {None, Normal, Limited, Strict}
    Setting<Limit> limit = register(new Setting("Limit", Limit.None, v -> page.getValue() == Page.Phase));
    enum Limit {None, Strong, Strict}
    Setting<Boolean> constrict = register(new Setting("Constrict", false, v -> page.getValue() == Page.Phase));
    Setting<Boolean> jitter = register(new Setting("Jitter", false, v -> page.getValue() == Page.Phase));

    Setting<Boolean> tickBoost = register(new Setting("TickBoost", false, v -> page.getValue() == Page.TickBoost));
    Setting<Integer> tickFactor = register(new Setting("TickFactor", 4, 1, 32, v -> page.getValue() == Page.TickBoost && tickBoost.getValue()));
    Setting<Double> cooldown = register(new Setting("Cooldown", 6.6d, 1.0d, 12.0d, v -> page.getValue() == Page.TickBoost && tickBoost.getValue()));

    Map<Integer, TimeVec3d> posLooks = new ConcurrentHashMap<>();
    ArrayList<CPacketPlayer> packets = new ArrayList<>();
    CPacketPlayer.Position startingOutOfBoundsPos;
    Timer doubleTapTimer = new Timer();
    Timer cooldownTimer = new Timer();
    Random random = new Random();
    boolean limitStrict = false;
    boolean oddJitter = false;
    float postPitch = -400F;
    int antiKickTicks = 0;
    float postYaw = -400F;
    int factorCounter = 0;
    int jitterTicks = 0;
    int limitTicks = 0;
    double speedX = 0;
    double speedY = 0;
    double speedZ = 0;
    int vDelay = 0;
    int hDelay = 0;
    int teleportId;
    int runs = 0;

    @Override
    public void onToggle() {
        doubleTapTimer.reset();
        cooldownTimer.reset();
        runs = 0;
    }

    @Override
    public String getDisplayInfo() {
        if (cooldownTimer != null && tickBoost.getValue()) {
            return (String.valueOf(cooldownTimer.passedMs((int)(cooldown.getValue() * 1000.0d)) ? ChatFormatting.GREEN : ChatFormatting.RED) + MathUtil.round((cooldownTimer.getPassedTimeMs() / 1000.0d), 1));
        }
        return null;
    }

    @Override
    public void onUpdate() {
        if (fullNullCheck()) {
            return;
        }
        if (shouldTickBoost()) {
            if (Cascade.timerManager.isFlagged()) {
                cooldownTimer.reset();
            }
            if (cooldownTimer.passedMs((int) (cooldown.getValue() * 1000.0d))) {
                if (MovementUtil.isMoving()) {
                    if (runs < tickFactor.getValue()) {
                        runs++;
                        PhysicsUtil.runPhysicsTick();
                    } else {
                        runs = 0;
                    }
                    cooldownTimer.reset();
                }
            }
        }
    }

    boolean shouldTickBoost() {
        return tickBoost.getValue() && !Cascade.serverManager.isServerNotResponding(1050);
    }

    @SubscribeEvent
    public void onMove(MoveEvent e) {
        if (fullNullCheck() || isDisabled()) {
            return;
        }
        if (mc.player.ticksExisted % 20 == 0) {
            cleanPosLooks();
        }
        mc.player.setVelocity(0.0d, 0.0d, 0.0d);
        if (teleportId <= 0 && type.getValue() != Type.SetBack) {
            startingOutOfBoundsPos = new CPacketPlayer.Position(randomHorizontal(), 1, randomHorizontal(), mc.player.onGround);
            packets.add(startingOutOfBoundsPos);
            mc.getConnection().sendPacket(startingOutOfBoundsPos);
            return;
        }

        boolean phasing = checkCollisionBox();
        speedX = 0;
        speedY = 0;
        speedZ = 0;

        if (mc.gameSettings.keyBindJump.isKeyDown() && (hDelay < 1 || (multiAxis.getValue() && phasing))) {
            if (mc.player.ticksExisted % (type.getValue() == Type.SetBack || type.getValue() == Type.Slow || limit.getValue() == Limit.Strict ? 10 : 20) == 0) {
                speedY = (antiKickMode.getValue() != AntiKick.None) ? -0.032 : 0.062;
            } else {
                speedY = 0.062;
            }
            antiKickTicks = 0;
            vDelay = 5;
        } else if (!mc.gameSettings.keyBindJump.isKeyDown() && mc.gameSettings.keyBindSneak.isKeyDown() && (hDelay < 1 || (multiAxis.getValue() && phasing))) {
            speedY = -0.062;
            antiKickTicks = 0;
            vDelay = 5;
        }

        if ((multiAxis.getValue() && phasing) || !(mc.gameSettings.keyBindSneak.isKeyDown() && mc.gameSettings.keyBindJump.isKeyDown())) {
            if (MovementUtil.isMoving()) {
                double[] dir = MovementUtil.strafe((phasing && phase.getValue() == Phase.NCP ? (noPhaseSlow.getValue() ? (multiAxis.getValue() ? 0.0465 : 0.062) : 0.031) : 0.26) * speed.getValue());
                if ((dir[0] != 0 || dir[1] != 0) && (vDelay < 1 || (multiAxis.getValue() && phasing))) {
                    speedX = dir[0];
                    speedZ = dir[1];
                    hDelay = 5;
                }
            }
            if (antiKickMode.getValue() != AntiKick.None && (limit.getValue() == Limit.None || limitTicks != 0)) {
                if (antiKickTicks < (packetMode.getValue() == Mode.Bypass && !bounds.getValue() ? 1 : 3)) {
                    antiKickTicks++;
                } else {
                    antiKickTicks = 0;
                    if (antiKickMode.getValue() != AntiKick.Limited || !phasing) {
                        speedY = antiKickMode.getValue() == AntiKick.Strict ? -0.08 : -0.04;
                    }
                }
            }
        }

        if (phasing) {
            if (phase.getValue() == Phase.NCP && (double) mc.player.moveForward != 0.0 || (double) mc.player.moveStrafing != 0.0 && speedY != 0) {
                speedY /= 2.5;
            }
        }

        if (limit.getValue() != Limit.None) {
            if (limitTicks == 0) {
                speedX = 0;
                speedY = 0;
                speedZ = 0;
            } else if (limitTicks == 2 && jitter.getValue()) {
                if (oddJitter) {
                    speedX = 0;
                    speedY = 0;
                    speedZ = 0;
                }
                oddJitter = !oddJitter;
            }
        } else if (jitter.getValue() && jitterTicks == 7) {
            speedX = 0;
            speedY = 0;
            speedZ = 0;
        }

        switch (type.getValue()) {
            case Fast:
                mc.player.setVelocity(speedX, speedY, speedZ);
                sendPackets(speedX, speedY, speedZ, packetMode.getValue(), true, false);
                break;
            case Slow:
                sendPackets(speedX, speedY, speedZ, packetMode.getValue(), true, false);
                break;
            case SetBack:
                mc.player.setVelocity(speedX, speedY, speedZ);
                sendPackets(speedX, speedY, speedZ, packetMode.getValue(), false, false);
                break;
            case Factor:
            case DeSync:
                float rawFactor = factor.getValue();
                int factorInt = (int) Math.floor(rawFactor);
                factorCounter++;
                if (factorCounter > (int) (20D / ((rawFactor - (double) factorInt) * 20D))) {
                    factorInt += 1;
                    factorCounter = 0;
                }
                for (int i = 1; i <= factorInt; ++i) {
                    mc.player.setVelocity(speedX * i, speedY * i, speedZ * i);
                    sendPackets(speedX * i, speedY * i, speedZ * i, packetMode.getValue(), true, false);
                }
                speedX = mc.player.motionX;
                speedY = mc.player.motionY;
                speedZ = mc.player.motionZ;
                break;
        }

        vDelay--;
        hDelay--;

        if (constrict.getValue() && (limit.getValue() == Limit.None || limitTicks > 1)) {
            mc.getConnection().sendPacket(new CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, false));
        }

        limitTicks++;
        jitterTicks++;

        if (limitTicks > ((limit.getValue() == Limit.Strict) ? (limitStrict ? 1 : 2) : 3)) {
            limitTicks = 0;
            limitStrict = !limitStrict;
        }

        if (jitterTicks > 7) {
            jitterTicks = 0;
        }

        if (type.getValue() != Type.SetBack && teleportId <= 0) {
            return;
        }

        if (type.getValue() != Type.Slow) {
            e.setX(speedX);
            e.setY(speedY);
            e.setZ(speedZ);
        }

        if (phase.getValue() == Phase.Vanilla || checkCollisionBox()) {
            mc.player.noClip = true;
        }
    }

    void sendPackets(double x, double y, double z, Mode mode, boolean sendConfirmTeleport, boolean sendExtraCT) {
        Vec3d nextPos = new Vec3d(mc.player.posX + x, mc.player.posY + y, mc.player.posZ + z);
        Vec3d bounds = getBoundsVec(x, y, z, mode);

        CPacketPlayer nextPosPacket = new CPacketPlayer.Position(nextPos.x, nextPos.y, nextPos.z, mc.player.onGround);
        packets.add(nextPosPacket);
        mc.getConnection().sendPacket(nextPosPacket);

        if (limit.getValue() != Limit.None && limitTicks == 0) {
            return;
        }

        CPacketPlayer boundsPacket = new CPacketPlayer.Position(bounds.x, bounds.y, bounds.z, mc.player.onGround);
        packets.add(boundsPacket);
        mc.getConnection().sendPacket(boundsPacket);

        if (sendConfirmTeleport) {
            teleportId++;
            if (sendExtraCT) {
                mc.getConnection().sendPacket(new CPacketConfirmTeleport(teleportId - 1));
            }

            mc.getConnection().sendPacket(new CPacketConfirmTeleport(teleportId));

            posLooks.put(teleportId, new TimeVec3d(nextPos.x, nextPos.y, nextPos.z, System.currentTimeMillis()));

            if (sendExtraCT) {
                mc.getConnection().sendPacket(new CPacketConfirmTeleport(teleportId + 1));
            }
        }

        /*
        if (type.getValue() != Type.FACTOR && type.getValue() != Type.NOJITTER && packetMode.getValue() != Mode.Bypass) {
            CPacketPlayer currentPos = new CPacketPlayer.Position(mc.player.posX, mc.player.posY, mc.player.posZ, false);
            packets.add(currentPos);
            mc.getConnection().sendPacket(currentPos);
        }
         */
    }

    Vec3d getBoundsVec(double x, double y, double z, Mode mode) {
        switch (mode) {
            case Up:
                return new Vec3d(mc.player.posX + x, bounds.getValue() ? (strict.getValue() ? 255 : 256) : mc.player.posY + 420, mc.player.posZ + z);
            case Preserve:
                return new Vec3d(bounds.getValue() ? mc.player.posX + randomHorizontal() : randomHorizontal(), strict.getValue() ? (Math.max(mc.player.posY, 2D)) : mc.player.posY, bounds.getValue() ? mc.player.posZ + randomHorizontal() : randomHorizontal());
            case LimitJitter:
                return new Vec3d(mc.player.posX + (strict.getValue() ? x : randomLimitedHorizontal()), mc.player.posY + randomLimitedVertical(), mc.player.posZ + (strict.getValue() ? z : randomLimitedHorizontal()));
            case Bypass:
                if (bounds.getValue()) {
                    double rawY = y * 510;
                    return new Vec3d(mc.player.posX + x, mc.player.posY + ((rawY > ((mc.player.dimension == -1) ? 127 : 255)) ? -rawY : (rawY < 1) ? -rawY : rawY), mc.player.posZ + z);
                } else {
                    return new Vec3d(mc.player.posX + (x == 0D ? (random.nextBoolean() ? -10 : 10) : x * 38), mc.player.posY + y, mc.player.posX + (z == 0D ? (random.nextBoolean() ? -10 : 10) : z * 38));
                }
            case Obscure:
                return new Vec3d(mc.player.posX + randomHorizontal(), Math.max(1.5D, Math.min(mc.player.posY + y, 253.5D)), mc.player.posZ + randomHorizontal());
            default:
                return new Vec3d(mc.player.posX + x, bounds.getValue() ? (strict.getValue() ? 1 : 0) : mc.player.posY - 1337, mc.player.posZ + z);
        }
    }

    double randomHorizontal() {
        int randomValue = random.nextInt(bounds.getValue() ? 80 : (packetMode.getValue() == Mode.Obscure ? (mc.player.ticksExisted % 2 == 0 ? 480 : 100) : 29000000)) + (bounds.getValue() ? 5 : 500);
        if (random.nextBoolean()) {
            return randomValue;
        }
        return -randomValue;
    }

    double randomLimitedVertical() {
        int randomValue = random.nextInt(22);
        randomValue += 70;
        if (random.nextBoolean()) {
            return randomValue;
        }
        return -randomValue;
    }

    double randomLimitedHorizontal() {
        int randomValue = random.nextInt(10);
        if (random.nextBoolean()) {
            return randomValue;
        }
        return -randomValue;
    }

    void cleanPosLooks() {
        posLooks.forEach((tp, timeVec3d) -> {
            if (System.currentTimeMillis() - timeVec3d.getTime() > TimeUnit.SECONDS.toMillis(30L)) {
                posLooks.remove(tp);
            }
        });
    }

    @Override
    public void onEnable() {
        if (fullNullCheck()) {
            return;
        }
        packets.clear();
        posLooks.clear();
        teleportId = 0;
        vDelay = 0;
        hDelay = 0;
        postYaw = -400F;
        postPitch = -400F;
        antiKickTicks = 0;
        limitTicks = 0;
        jitterTicks = 0;
        speedX = 0;
        speedY = 0;
        speedZ = 0;
        oddJitter = false;
        startingOutOfBoundsPos = null;
        startingOutOfBoundsPos = new CPacketPlayer.Position(randomHorizontal(), 1, randomHorizontal(), mc.player.onGround);
        packets.add(startingOutOfBoundsPos);
        mc.getConnection().sendPacket(startingOutOfBoundsPos);
    }

    @SubscribeEvent
    public void onPacketReceive(PacketEvent.Receive e) {
        if (fullNullCheck() || isDisabled()) {
            teleportId = 0;
            return;
        }
        if (e.getPacket() instanceof SPacketPlayerPosLook) {
            SPacketPlayerPosLook packet = e.getPacket();
            if (mc.player.isEntityAlive()) {
                if (this.teleportId <= 0) {
                    this.teleportId = ((SPacketPlayerPosLook) e.getPacket()).getTeleportId();
                } else {
                    if (mc.world.isBlockLoaded(new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ), false) && type.getValue() != Type.SetBack) {
                        if (type.getValue() == Type.DeSync) {
                            posLooks.remove(packet.getTeleportId());
                            e.setCanceled(true);
                            if (type.getValue() == Type.Slow) {
                                mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());
                            }
                            return;
                        } else if (posLooks.containsKey(packet.getTeleportId())) {
                            TimeVec3d vec = posLooks.get(packet.getTeleportId());
                            if (vec.x == packet.getX() && vec.y == packet.getY() && vec.z == packet.getZ()) {
                                posLooks.remove(packet.getTeleportId());
                                e.setCanceled(true);
                                if (type.getValue() == Type.Slow) {
                                    mc.player.setPosition(packet.getX(), packet.getY(), packet.getZ());
                                }
                                return;
                            }
                        }
                    }
                }
            }
            ((ISPacketPlayerPosLook) packet).setYaw(mc.player.rotationYaw);
            ((ISPacketPlayerPosLook) packet).setPitch(mc.player.rotationPitch);
            packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.X_ROT);
            packet.getFlags().remove(SPacketPlayerPosLook.EnumFlags.Y_ROT);
            teleportId = packet.getTeleportId();
        }
    }

    boolean checkCollisionBox() {
        if (!mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().expand(0.0, 0.0, 0.0)).isEmpty()) {
            return true;
        }
        return !mc.world.getCollisionBoxes(mc.player, mc.player.getEntityBoundingBox().offset(0.0, 2.0, 0.0).contract(0.0, 1.99, 0.0)).isEmpty();
    }

    @SubscribeEvent
    public void onPacketSend(PacketEvent.Send e) {
        if (fullNullCheck() || isDisabled()) {
            return;
        }

        if (e.getPacket() instanceof CPacketPlayer && !(e.getPacket() instanceof CPacketPlayer.Position)) {
            e.setCanceled(true);
        }
        if (e.getPacket() instanceof CPacketPlayer) {
            CPacketPlayer packet = e.getPacket();
            if (packets.contains(packet)) {
                packets.remove(packet);
                return;
            }
            e.setCanceled(true);
        }
    }
}